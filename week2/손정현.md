# 제네레이터와 이터레이터

## 제네레이터와 이터리에터

### 제네레이터란?

제네레이터는 `이터레이터이자 이터러블을 생성하는 함수` 를 말합니다.

제네레이터를 활용하면 쉽게 이터레이터를 만들 수 있습니다.

여기서 이터레이터는 `Symbol.iterator` 를 가지고 있기 때문에 

이터레이터이자 이터러블 합니다.

따라서 제네레이터는 `well formed iterator` 를 반환하는 함수인 것입니다.

```jsx
function *gen() {
  yield 1;
  yield 2;
  yield 3;
	return 100; // 마지막 done: true 에서 반환되는 값
}

const iter = gen();
console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: 100, done: true }

// 또는 다음과 같이 순회도 가능합니다.
for (const a of gen()) {
	console.log(a);
}
```

### 제네레이터를 활용한 홀수 생성기 예제 (odds)

```jsx
function* infinity(i = 0) {
  while (true) {
    yield i++;
  }
}

function* limit(l, iter) {
  for (const a of iter) {
    yield a;
    if (a == l) {
      return;
    }
  }
}

function* odds(l) {
  for (const a of limit(l, infinity(1))) {
    if (a % 2) {
      yield a;
    }
    if (a == l) {
      return;
    }
  }
}

const iter2 = odds(10);
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());
console.log(iter2.next());

for (const a of odds(40)) {
  console.log(a)
}
```

### for of, 전개 연산자, 구조 분해, 나머지 연산자

제네레이터는 `이터러블/이터레이터 프로토콜` 을 준수하기 때문에

`for of, 전개 연산자, 구조 분해, 나머지 연산자` 등과 같이 JS 에서 이터러블 프로토콜을 

따르고 있는 문법들과 함께 사용할 수 있습니다.

```jsx
// 위 예제에 이어서..

console.log(...odds(10))
console.log([...odds(10), ...odds(20)])

const [head, ...tail] = odds(5);
console.log(head); // 1
console.log(tail); // [3, 5]
```

# map, filter, reduce

## map

### map 함수에 대해서

`map` 함수의 경우 `이터러블 프로토콜을 따르는 객체` 와 `추출대상에 대한 보조함수` 를 

매개 변수로 필요로 합니다.

이러한 보조 함수를 통해 로직의 추상화와 위임이 가능해집니다.

```jsx
const products = [
  { name: '반팔티', price: 15000 },
  { name: '긴팔티', price: 20000 },
  { name: '핸드폰케이스', price: 15000 },
  { name: '후드티', price: 30000 },
  { name: '바지', price: 25000 }
]

const map = (f, iter) => {
  let res = [];
  for (const a of iter) {
    res.push(f(a));
  }

  return res;
}

const price = map(p => p.price, products); 
console.log(price); // [ 15000, 20000, 15000, 30000, 25000 ]
```

### 이터러블 프로토콜을 따른 map 의 다형성

다음 코드는 에러를 반환합니다.

```jsx
document.querySelectorAll('*').map(el => el.nodeName)
```

이는 `document.querySelectorAll` 이 `Array` 를 상속받은 객체가 아니기 때문입니다.

따라서 `map` 함수를 가지고 있지 않습니다.

다만 앞에서 구현한 `map` 함수는 잘 동작합니다.

```jsx
map(el => el.nodeName, document.querySelectorAll('*'))
```

이는 `document.querySelectorAll` 이 이터러블 프로토콜을 따르고 있기 때문입니다.

그렇다면 사용자가 정의한 제네레이터 함수는 어떻게 될까요?

```jsx
function* gen() {
  yield 2;
  yield 3;
  yield 4;
}

console.log(map(a => a * a, gen())) // [4, 9, 16]
```

마찬가지로 제네레이터는 이터레이터를 반환하기 때문에 동일하게 잘 동작합니다.

추가적으로 ES6 에 새롭게 추가된 자료 구조인 `Map` 또한 이터러블 프로토콜을 따릅니다.

```jsx
const m = new Map();
m.set('a', 10);
m.set('b', 20);

console.log(map(([k, v]) => [k, v * 2], m)); // [ [ 'a', 20 ], [ 'b', 40 ] ]
```

## filter

`filter` 는 특정 조건에 부합하는 요소만 걸러내는 역할을 합니다.

```jsx
const filter = (f, iter) => {
  const res = [];

  for (const a of iter) {
    if (f(a)) {
      res.push(a);
    }
  }

  return res;
}

console.log(filter(p => p.price < 20000, products)); // [ { name: '반팔티', price: 15000 }, { name: '핸드폰케이스', price: 15000 } ]
```

## reduce

`reduce` 는 이터러블의 값을 하나의 값으로 축약하는 함수입니다.

이 함수 또한 보조 함수를 통해 내부의 다형성을 잘 지원하는 형태입니다.

```jsx
const nums = [1, 2, 3, 4, 5];

const reduce = (f, acc, iter) => {
  if (!iter) {
    /**
     * 초기값 생략하는 방식 처리
     */
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  }

  for (const a of iter) {
    acc = f(acc, a);
  }

  return acc;
};

const add = (a, b) => a + b;

console.log(reduce(add, 0, [1, 2, 3, 4, 5])); // 15
console.log(reduce(add, [1, 2, 3, 4, 5])); // 15 
```
